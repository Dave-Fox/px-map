{"version":3,"sources":["px-map-mixin-layer.es6.js"],"names":["MapLayerLifecycleMixin","superclass","elementInst","options","__initialOptions","getOptions","createInst","parent","hasLayer","addLayer","remove","__elAttached","canAddInst","notifyInstReady","lastOptions","__lastOptions","nextOptions","updateInst","Error","MapLayerChildMixin","willRemoveInst","removeInst","isReady","fire","MapLayerParentMixin","_attachedChildren","WeakMap","listen","_tryToAddAllChildren","bind","_tryToAddOneChild","_detachLayerChildren","evt","srcElement","_attachLayerChildren","stopPropagation","_attachLayerChild","children","getEffectiveChildren","length","child","childEl","has","willAddInst","addInst","set","async","_detachLayerChild","delete","mixins","window","PxMapMixin","MapLayerLifecycle","MapLayerChild","MapLayerParent","MapLayerParentMixinMixin","MapLayer","arguments","initialize","mixwith","mix","with","MapElement"],"mappings":"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","file":"px-map-mixin-layer.js","sourcesContent":["(function() {\n  'use strict';\n\n  /**\n   *\n   *\n   * @mixin MapLayerLifecycle\n   */\n  let MapLayerLifecycleMixin = (superclass) => class extends superclass {\n    // Lifecycle hooks for LayerBase, will be called by a LayerParent\n\n    willAddInst() {\n      if (this.elementInst) return;\n\n      const options = this.__initialOptions = this.getOptions();\n      this.elementInst = this.createInst(options);\n\n      // @TODO: Bind events\n    }\n\n    willRemoveInst() {\n      // @TODO: Unbind events\n    }\n\n    addInst(parent) {\n      if (!parent || parent.hasLayer(this.elementInst)) return;\n      parent.addLayer(this.elementInst);\n    }\n\n    removeInst() {\n      if (!this.elementInst) return;\n      this.elementInst.remove();\n    }\n\n    // Simple observer trigger for dynamic properties that should be synced\n    // to the instance\n\n    shouldUpdateInst() {\n      if (!this.elementInst && this.__elAttached && this.canAddInst()) {\n        this.notifyInstReady(this.canAddInst());\n      }\n      if (!this.elementInst) return;\n\n      const lastOptions = this.__lastOptions || this.__initialOptions;\n      const nextOptions = this.getOptions();\n\n      this.updateInst(lastOptions, nextOptions);\n\n      // Set `lastOptions` to `nextOptions` so the next time this method is called\n      // it will have access to the last options\n      this.__lastOptions = nextOptions;\n    }\n\n    // Should be implemented by behaviors/components that extend LayerBase\n\n    createInst() {\n      throw new Error('The `createInst` method must be implemented.')\n    }\n\n    updateInst() {\n      throw new Error('The `updateInst` method must be implemented.')\n    }\n\n    getOptions() {\n      throw new Error('The `getOptions` method must be implemented.')\n    }\n  };\n\n  /**\n   *\n   *\n   * @mixin MapLayerChild\n   */\n  let MapLayerChildMixin = (superclass) => class extends superclass {\n\n    // When this element is attached to the DOM, fire an event to notify\n    // a parent that it is ready\n\n    created() {\n      this.__elAttached = false;\n    }\n\n    attached() {\n      this.__elAttached = true;\n      this.notifyInstReady(this.canAddInst());\n    }\n\n    // When this element is detached from the DOM, its elementInst should be\n    // removed from the parent\n\n    detached() {\n      this.willRemoveInst();\n      this.removeInst();\n      this.__elAttached = false;\n    }\n\n    /**\n     * Some element instances may require a minimum number of defined options\n     * to be able to attach to their parent. If those options are defined via.\n     * attributes, they may not be deserialized or even set before the `willAddInst`\n     * method is called.\n     *\n     * Elements that need to defer until some options are set should override\n     * the `canAddInst` method and return `false` if the method\n     *\n     * Elements that may need to defer until some options are ready should\n     * override `instReady` and set it to `false` by default.\n     *\n     * Later, when the `updateInst` function is called, the element should check\n     * if all required options are set and call the method `this.notifyInstReady(true)`\n     * to trigger an event the parent will catch and use to attach this element.\n     */\n    canAddInst() {\n      return true;\n    }\n\n    /**\n     * If this element's instance is ready to create and add to its parent,\n     * fires an event the parent will catch.\n     *\n     * @param {Boolean} isReady - If `true` instance parent will be notified\n     * @return {Boolean} - If `true` the parent was notified\n     */\n    notifyInstReady(isReady) {\n      if (!isReady) return false;\n      this.fire('px-map-layer-ready-to-add');\n      return true;\n    }\n  };\n\n  /**\n   *\n   *\n   * @mixin MapLayerParent\n   */\n  let MapLayerParentMixin = (superclass) => class extends superclass {\n    created() {\n      // Use a WeakMap to keep track of our attached children\n      this._attachedChildren = this._attachedChildren || new WeakMap();\n    }\n\n    attached() {\n      this.listen(this, 'px-map-layer-instance-created', this._tryToAddAllChildren.bind(this));\n      this.listen(this, 'px-map-layer-ready-to-add', this._tryToAddOneChild.bind(this));\n    }\n\n    detached() {\n      this._detachLayerChildren();\n    }\n\n    // Handles attaching children throughout this element's lifecycle\n\n    _tryToAddAllChildren(evt) {\n      // If this element's elementInst isn't ready, halt and wait until later\n      // If this event isn't coming from this element, do not handle\n      if (!this.elementInst || evt.srcElement !== this) return;\n\n      // If my own elementInst was just created, loop over children and try to attach them\n      this._attachLayerChildren();\n    }\n\n    _tryToAddOneChild(evt) {\n      // If the added-to-dom event belongs to this element, just return and let it bubble\n      if (evt.srcElement === this) return;\n\n      // This element is the parent, so stop this event from bubbling\n      evt.stopPropagation();\n\n      // If I have no elementInst, halt and wait until later\n      if (!this.elementInst) return;\n\n      this._attachLayerChild(evt.srcElement);\n    }\n\n    _attachLayerChildren() {\n      const children = this.getEffectiveChildren();\n      if (!children || !children.length) return;\n\n      for (let child of children) {\n        this._attachLayerChild(child);\n      }\n    }\n\n    _attachLayerChild(childEl) {\n      if (this._attachedChildren.has(childEl) || !childEl.willAddInst || !childEl.addInst || !childEl.canAddInst || !childEl.canAddInst()) return;\n      this._attachedChildren.set(childEl, true);\n\n      this.async(() => { childEl.willAddInst(); });\n      this.async(() => { childEl.addInst(this.elementInst); });\n    }\n\n    // Handles detaching children throughout this element's lifecycle\n\n    _detachLayerChildren() {\n      const children = this.getEffectiveChildren();\n      if (!children || !children.length) return;\n\n      for (let child of children) {\n        this._detachLayerChild(child);\n      }\n    }\n\n    _detachLayerChild(childEl) {\n      if (!this._attachedChildren.has(childEl) || !childEl.willRemoveInst || !childEl.removeInst) return;\n      this._attachedChildren.delete(childEl);\n\n      this.async(() => { childEl.willRemoveInst(); });\n      this.async(() => { childEl.removeInst(this.elementInst); });\n    }\n  };\n\n  const mixins = (window.PxMapMixin = window.PxMapMixin || {});\n  mixins.MapLayerLifecycle = MapLayerLifecycleMixin;\n  mixins.MapLayerChild = MapLayerChildMixin;\n  mixins.MapLayerParent = MapLayerParentMixinMixin;\n\n  class MapLayer extends mixwith.mix().with(PxMapMixin.MapElement, PxMapMixin.MapLayerLifecycle, PxMapMixin.MapLayerChild, PxMapMixin.MapLayerParent) {\n    constructor() {\n      super(...arguments);\n      this.initialize();\n    }\n  }\n  //\n  // const klasses = (window.PxMap = window.PxMap || {});\n  // klasses.MapLayer = MapLayer;\n})();\n"]}