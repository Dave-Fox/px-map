{"version":3,"sources":["px-map-behavior-marker-group.es6.js"],"names":["namespace","window","PxMapBehavior","MarkerGroupImpl","properties","name","type","String","notify","data","Object","observer","colorsByType","value","getComputedStyleValue","iconFns","cluster","undefined","marker","addInst","parent","LayerImpl","call","spiderifyFn","_handleClusterSpiderify","bind","unspiderifyFn","_handleClusterUnspiderify","bindEvents","removeInst","createInst","options","L","markerClusterGroup","features","length","_syncDataWithMarkers","updateInst","lastOptions","nextOptions","elementInst","fire","getInstOptions","maxClusterRadius","spiderifyOnMaxZoom","iconCreateFunction","_createClusterIcon","markers","getAllChildMarkers","count","types","_indexClusterMarkersByType","colors","containerSize","_getClusterIconSize","pathSize","_getStyleValueAsNum","borderSize","countByType","PxMap","ClusterIcon","styleValName","__styleVals","computedVal","valWithoutSuffix","replace","valAsNum","Math","floor","e","reduce","featureProperties","newFeatures","clusterInst","featuresSet","_features","Set","markersMap","_markers","WeakMap","_diffNewFeatures","featuresToAdd","featuresToUpdate","featuresToRemove","nextFeaturesSet","nextMarkersMap","feature","cachedMarker","markersToOperate","size","get","_createMarker","push","set","addLayers","_updateMarker","refreshClusters","_removeMarker","delete","removeLayers","clear","lastFeatureSet","markerMap","i","len","valid","known","featureHash","id","geometry","coordinates","Array","has","add","hash","JSON","stringify","markerData","lat","lng","iconSettings","_extractIconSettings","icon","_createMarkerIcon","setIcon","featSettings","featSettingsKeys","keys","featKey","featKeyCamelized","substring","match","captured","charAt","toUpperCase","StaticIcon","evt","localEvt","Polymer","dom","node","_icon","style","visibility","MarkerGroup","Layer"],"mappings":"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","file":"px-map-behavior-marker-group.js","sourcesContent":["(function() {\n  'use strict';\n\n  /****************************************************************************\n   * BEHAVIORS\n   ****************************************************************************/\n\n  /* Ensures the behavior namespace is created */\n  const namespace = (window.PxMapBehavior = window.PxMapBehavior || {});\n\n  /**\n   *\n   * @polymerBehavior PxMapBehavior.MarkerGroup\n   */\n  const MarkerGroupImpl = {\n    properties: {\n      /**\n       * A human-readable name for this layer group. If the map has a layer\n       * control panel, the user will click this name to show, hide, or\n       * manipulate this layer.\n       *\n       * @type {String}\n       */\n      name: {\n        type: String,\n        notify: true\n      },\n\n      /**\n       * A GeoJSON FeatureCollection object containing an array of Features with\n       * point data that will be represented as a marker.\n       *\n       * @type {Object}\n       */\n      data: {\n        type: Object,\n        observer: 'shouldUpdateInst'\n      },\n\n      /**\n       * An object mapping categories of icons to their respective colors. Each\n       * key should be a string representing the name of an `icon-type` to\n       * a valid CSS color value (e.g. hex color, `rgb()` color). Set the\n       * `icon-type` as a sub-property of `properties.marker-icon` for each marker\n       * feature in the FeatureCollection you pass into the `data` attribute.\n       *\n       * By default, the available types are:\n       * - \"unknown\" : \"--px-map-marker-group-unknown-color\" (default: gray)\n       * - \"info\" : \"--px-map-marker-group-info-color\" (default: blue)\n       * - \"warning\" : \"--px-map-marker-group-info-color\" (default: yellow)\n       * - \"important\" : \"--px-map-marker-group-info-color\" (default: red)\n       *\n       * Example #1 - FeatureCollection for `data`:\n       *\n       * ```\n       * {\n       *   \"type\" : \"FeatureCollection\",\n       *   \"features\" : [\n       *     {\n       *       \"type\": \"Feature\",\n       *       \"id\": \"001\",\n       *       \"geometry\": { ... },\n       *       \"properties\": {\n       *         \"marker-icon\": {\n       *           \"icon-base\": \"StaticIcon\",\n       *           \"icon-type\": \"info\"\n       *         }\n       *       }\n       *     },\n       *     {\n       *       \"type\": \"Feature\",\n       *       \"id\": \"002\",\n       *       \"geometry\": { ... },\n       *       \"properties\": {\n       *         \"marker-icon\": {\n       *           \"icon-base\": \"StaticIcon\",\n       *           \"icon-type\": \"warning\"\n       *         }\n       *       }\n       *     }\n       *   ]\n       * }\n       * ```\n       *\n       * Example #1 - `colorsByType` object\n       *\n       * ```\n       * {\n       *   \"info\" : \"blue\",\n       *   \"warning\" : \"red\"\n       * }\n       * ```\n       *\n       * The default `colorsByType` mapping is:\n       */\n      colorsByType: {\n        type: Object,\n        value: function(){\n          return {\n            \"unknown\" : this.getComputedStyleValue('--px-map-marker-group-unknown-color'),\n            \"info\" : this.getComputedStyleValue('--px-map-marker-group-info-color'),\n            \"warning\" : this.getComputedStyleValue('--px-map-marker-group-warning-color'),\n            \"important\" : this.getComputedStyleValue('--px-map-marker-group-important-color')\n          }\n        }\n      },\n\n      iconFns: {\n        type: Object,\n        value: function(){\n          return {\n            cluster: undefined,\n            marker: undefined\n          }\n        }\n      }\n    },\n\n    addInst(parent) {\n      PxMapBehavior.LayerImpl.addInst.call(this, parent);\n\n      // Bind custom events for this cluster. Events will be unbound automatically.\n      const spiderifyFn = this._handleClusterSpiderify.bind(this);\n      const unspiderifyFn = this._handleClusterUnspiderify.bind(this);\n      this.bindEvents({\n        'spiderfied' : spiderifyFn,\n        'unspiderfied' : unspiderifyFn\n      });\n    },\n\n    removeInst(parent) {\n      PxMapBehavior.LayerImpl.removeInst.call(this, parent);\n    },\n\n    createInst(options={}) {\n      const cluster = L.markerClusterGroup(options);\n\n      if (options.data && options.data.features && options.data.features.length) {\n        this._syncDataWithMarkers(options.data.features, cluster);\n      }\n\n      return cluster;\n    },\n\n    updateInst(lastOptions, nextOptions) {\n      if (nextOptions.data && nextOptions.data.features && nextOptions.data.features.length) {\n        this._syncDataWithMarkers(nextOptions.data.features, this.elementInst);\n        this.fire('px-map-marker-group-add');\n      }\n    },\n\n    getInstOptions() {\n      return {\n        maxClusterRadius: 150,\n        spiderifyOnMaxZoom: true,\n        data: this.data,\n        iconCreateFunction: this.iconFns.cluster || this._createClusterIcon.bind(this)\n      };\n    },\n\n    _createClusterIcon(cluster) {\n      const markers = cluster.getAllChildMarkers();\n      const count = markers.length;\n\n      // Count markers and group by type\n      const types = this._indexClusterMarkersByType(markers);\n      // Get the colors for each type\n      const colors = this.colorsByType;\n\n      // Get the container size for this count\n      const containerSize = this._getClusterIconSize(count);\n      // Get the path (chart stroke width) and border width for this chart\n      const pathSize = this._getStyleValueAsNum('--px-map-marker-group-cluster-path-size') || 10;\n      const borderSize = this._getStyleValueAsNum('--px-map-marker-group-cluster-border-size') || 0;\n\n      // Set up the options to send into ClusterIcon\n      const options = {\n        count: count,\n        countByType: types,\n        colorsByType: colors,\n        containerSize: containerSize,\n        pathSize: pathSize,\n        borderSize: borderSize\n      };\n\n      return new PxMap.ClusterIcon(options);\n    },\n\n    _getStyleValueAsNum(styleValName) {\n      // Try to get from the \"cache\"\n      this.__styleVals = (this.__styleVals || {});\n      if (this.__styleVals[styleValName]) return this.__styleVals[styleValName];\n\n      const computedVal = this.getComputedStyleValue(styleValName);\n\n      try {\n        const valWithoutSuffix = computedVal.replace('px','');\n        const valAsNum = Math.floor(valWithoutSuffix);\n        this.__styleVals[styleValName] = valAsNum;\n        return valAsNum;\n      } catch (e) {\n        return undefined;\n      };\n    },\n\n    _getClusterIconSize(count) {\n      // for count 1-9, size is small\n      if (count < 10) {\n        return 60;\n      }\n      // for count 10-39, size is medium\n      if ((count >= 10) && (count < 40)) {\n        return 75;\n      }\n      // for count 40+, size is large\n      if (count > 40) {\n        return 90;\n      }\n    },\n\n    /**\n     * Takes a group of marker instances and returns an object with keys of the\n     * marker types in the group and values with the number of markers in\n     * each group.\n     *\n     * @param {Array} markers - Array of marker instances\n     * @return {Object}\n     */\n    _indexClusterMarkersByType(markers) {\n      return markers.reduce((types, marker) => {\n        if (marker.featureProperties && marker.featureProperties['marker-icon'] && marker.featureProperties['marker-icon']['icon-type']) {\n          types[marker.featureProperties['marker-icon']['icon-type']] = (types[marker.featureProperties['marker-icon']['icon-type']] || 0) + 1;\n        }\n        return types;\n      }, {});\n    },\n\n    _syncDataWithMarkers(newFeatures, clusterInst) {\n      if (!newFeatures.length) return;\n\n      const featuresSet = this._features = (this._features || new Set());\n      const markersMap = this._markers = (this._markers || new WeakMap());\n\n      const {featuresToAdd, featuresToUpdate, featuresToRemove, nextFeaturesSet, nextMarkersMap} = this._diffNewFeatures(newFeatures, featuresSet, markersMap);\n\n      let feature, cachedMarker, markersToOperate;\n\n      if (featuresToAdd.size) {\n        markersToOperate = [];\n        for (feature of featuresToAdd) {\n          cachedMarker = nextMarkersMap.get(feature);\n          cachedMarker.marker = this._createMarker(feature);\n          markersToOperate.push(cachedMarker.marker);\n          nextMarkersMap.set(feature, cachedMarker);\n        }\n        clusterInst.addLayers(markersToOperate);\n        markersToOperate = null;\n      }\n\n      if (featuresToUpdate.size) {\n        markersToOperate = [];\n        for (feature of featuresToUpdate) {\n          cachedMarker = nextMarkersMap.get(feature);\n          cachedMarker.marker = this._updateMarker(cachedMarker.marker);\n          markersToOperate.push(cachedMarker.marker);\n          nextMarkersMap.set(feature, cachedMarker);\n        }\n        clusterInst.refreshClusters(markersToOperate);\n        markersToOperate = null;\n      }\n\n      if (featuresToRemove.size) {\n        markersToOperate = [];\n        for (feature of featuresToRemove) {\n          cachedMarker = nextMarkersMap.get(feature);\n          this._removeMarker(cachedMarker.marker);\n          markersToOperate.push(cachedMarker.marker);\n          nextMarkersMap.delete(feature);\n        }\n        clusterInst.removeLayers(markersToOperate);\n        markersToOperate = null;\n      }\n\n      this._features = nextFeaturesSet;\n      this._markers = nextMarkersMap;\n      featuresSet.clear()\n\n      featuresToAdd.clear();\n      featuresToUpdate.clear();\n      featuresToRemove.clear();\n    },\n\n    _diffNewFeatures(newFeatures, lastFeatureSet, markerMap) {\n      // Keep track of our new feature set, which will replace `featureSet`\n      const nextFeaturesSet = new Set();\n\n      // Keep track of markers to add\n      const featuresToAdd = new Set();\n      const featuresToUpdate = new Set();\n\n      // Placeholders for our loop\n      let i, len, valid, known, cachedMarker, featureHash;\n\n      // Loop over features to add unknown features to the cluster or update known features if necessary\n      for (i=0, len=newFeatures.length; i<len; i++) {\n        // If these tests aren't met, the feature is invalid and can't be drawn as a marker\n        // Any invalid markers won't be visited and will be removed\n        valid = ((newFeatures[i].id) && (newFeatures[i].geometry && newFeatures[i].geometry.type === 'Point') && (newFeatures[i].geometry.coordinates instanceof Array && newFeatures[i].geometry.coordinates.length === 2));\n        if (!valid) continue;\n\n        // Determine if this feature is already represented in the cluster\n        known = lastFeatureSet.has(newFeatures[i]);\n\n        // This is a valid feature we don't know, create a marker for this feature and add it.\n        if (!known) {\n          // Mark this as a marker to add\n          featuresToAdd.add(newFeatures[i]);\n          // Remove from last feature set and add to next feature set\n          lastFeatureSet.delete(newFeatures[i]);\n          nextFeaturesSet.add(newFeatures[i]);\n          // Build a new cached marker object with a hash of the feature\n          cachedMarker = { marker: null, hash: JSON.stringify(newFeatures[i]) };\n          markerMap.set(newFeatures[i], cachedMarker);\n          // Skip to next loop iteration\n          continue;\n        }\n\n        // We know this feature and have a marker for it. Ensure the marker is up-to-date.\n        if (known) {\n          cachedMarker = markerMap.get(newFeatures[i]);\n          featureHash = JSON.stringify(newFeatures[i]);\n          // If there's a difference, mark this marker as one to update\n          if (cachedMarker.hash !== featureHash) {\n            featuresToUpdate.add(newFeatures[i]);\n            // Update the cached marker object with the new hash of the feature\n            cachedMarker.hash = featureHash;\n            markerMap.set(newFeatures[i], cachedMarker);\n          }\n          // Remove from last feature set and add to next feature set\n          lastFeatureSet.delete(newFeatures[i]);\n          nextFeaturesSet.add(newFeatures[i]);\n        }\n      }\n\n      // Any markers remaining in the last feature set need to be remove\n      const featuresToRemove = lastFeatureSet.size ? lastFeatureSet : new Set();\n\n      // Clear all references in the last feature set to ensure values can\n      // be garbage collected\n      lastFeatureSet.clear();\n      lastFeatureSet = null;\n\n      return {\n        featuresToAdd: featuresToAdd,\n        featuresToUpdate: featuresToUpdate,\n        featuresToRemove: featuresToRemove,\n        nextFeaturesSet: nextFeaturesSet,\n        nextMarkersMap: markerMap\n      };\n    },\n\n    _removeMarker(markerData, clusterInst){\n      // debugger;\n    },\n\n    _createMarker(feature, clusterInst) {\n      // Extract geometry (GeoJSON coordinate pairs are Lat/Lng, we need Lng/Lat,\n      // so we have to reverse)\n      const [lat, lng] = feature.geometry.coordinates;\n      // Create a marker\n      const marker = L.marker([lng, lat]);\n\n      // If any icon settings were passed with the feature, fetch them to pass\n      // to the icon constructor\n      const iconSettings = (feature.properties['marker-icon']) ? this._extractIconSettings(feature.properties['marker-icon']) : {};\n      const icon = this.iconFns.marker ? this.iconFns.marker.call(this, iconSettings) : this._createMarkerIcon(iconSettings);\n      marker.setIcon(icon);\n\n      // Attach the properties to the marker instance to read later\n      marker.featureProperties = feature.properties;\n\n      return marker;\n    },\n\n    _extractIconSettings(featSettings) {\n      const featSettingsKeys = Object.keys(featSettings);\n      if (!featSettingsKeys.length) return undefined;\n\n      const iconSettings = {};\n      let i, len, featKey, featKeyCamelized;\n\n      for (i=0, len=featSettingsKeys.length; i<len; i++) {\n        featKey = featSettingsKeys[i];\n        if (featKey.substring(0,5) !== \"icon-\") continue;\n        featKeyCamelized = featKey.substring(5).replace(/(\\-[a-z])/g, (match, captured) => captured.charAt(1).toUpperCase());\n        iconSettings[featKeyCamelized] = featSettings[featKey];\n      }\n\n      return iconSettings;\n    },\n\n    _createMarkerIcon(options) {\n      return new PxMap.StaticIcon(options);\n    },\n\n    /**\n     * When the cluster is spiderified, set its visibility to hidden to ensure\n     * it is not kept around as an opaque background to the markers.\n     */\n    _handleClusterSpiderify(evt) {\n      const localEvt = Polymer.dom(evt);\n      const node = localEvt.node;\n      if (!node || !node.cluster || !node.cluster._icon) return;\n\n      node.cluster._icon.style.visibility = 'hidden';\n    },\n\n    /**\n     * When the cluster is unspiderified, set its visibility to visible to ensure\n     * it is shown again on the map.\n     */\n    _handleClusterUnspiderify(evt) {\n      const localEvt = Polymer.dom(evt);\n      const node = localEvt.node;\n      if (!node || !node.cluster || !node.cluster._icon) return;\n\n      node.cluster._icon.style.visibility = 'visible';\n    }\n  };\n  /* Bind MarkerGroup behavior */\n  namespace.MarkerGroup = [\n    namespace.Layer,\n    MarkerGroupImpl\n  ];\n\n})();\n"]}