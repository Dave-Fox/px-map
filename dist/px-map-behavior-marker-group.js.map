{"version":3,"sources":["px-map-behavior-marker-group.es6.js"],"names":["namespace","window","PxMapBehavior","MarkerGroupImpl","properties","name","type","String","notify","data","Object","observer","colorsByType","value","getComputedStyleValue","createInst","options","boundCreateClusterIcon","_createClusterIcon","bind","iconCreateFunction","cluster","L","markerClusterGroup","features","length","_syncDataWithMarkers","updateInst","lastOptions","nextOptions","elementInst","getInstOptions","maxClusterRadius","markers","getAllChildMarkers","count","types","_indexClusterMarkersByType","colors","containerSize","_getClusterIconSize","pathSize","_getStyleValueAsNum","borderSize","countByType","PxMap","ClusterIcon","styleValName","__styleVals","computedVal","valWithoutSuffix","replace","valAsNum","Math","floor","e","undefined","reduce","marker","featureProperties","_generateClusterMarkerClasses","markerCount","markerTypeCount","newFeatures","clusterInst","featuresSet","_features","Set","markersMap","_markers","WeakMap","_diffNewFeatures","featuresToAdd","featuresToUpdate","featuresToRemove","nextFeaturesSet","nextMarkersMap","feature","cachedMarker","markersToOperate","size","get","_createMarker","push","set","addLayers","_updateMarker","refreshClusters","_removeMarker","delete","removeLayers","clear","lastFeatureSet","markerMap","i","len","valid","known","featureHash","id","geometry","coordinates","Array","has","add","hash","JSON","stringify","markerData","lat","lng","withBadge","icon","StaticIcon","setIcon","_createMarkerOLDOLD","PruneCluster","Marker","_createMarkerIcon","markerCategory","badge","_findForgottenMarkers","remembered","markerList","entries","markersToRemove","_ensureMarkerMatchesData","MarkerGroup","Layer"],"mappings":"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","file":"px-map-behavior-marker-group.js","sourcesContent":["(function() {\n  'use strict';\n\n  /****************************************************************************\n   * BEHAVIORS\n   ****************************************************************************/\n\n  /* Ensures the behavior namespace is created */\n  const namespace = (window.PxMapBehavior = window.PxMapBehavior || {});\n\n  /**\n   *\n   * @polymerBehavior PxMapBehavior.MarkerGroup\n   */\n  const MarkerGroupImpl = {\n    properties: {\n      /**\n       * A human-readable name for this layer group. If the map has a layer\n       * control panel, the user will click this name to show, hide, or\n       * manipulate this layer.\n       *\n       * @type {String}\n       */\n      name: {\n        type: String,\n        notify: true\n      },\n\n      /**\n       * A GeoJSON FeatureCollection object containing an array of Features with\n       * point data that will be represented as a marker.\n       *\n       * @type {Object}\n       */\n      data: {\n        type: Object,\n        observer: 'shouldUpdateInst'\n      },\n\n      /**\n       * An object mapping categories of icons to their respective colors. Each\n       * key should be a string representing the name of an `icon-type` to\n       * a valid CSS color value (e.g. hex color, `rgb()` color). Set the\n       * `icon-type` as a sub-property of `properties.marker-icon` for each marker\n       * feature in the FeatureCollection you pass into the `data` attribute.\n       *\n       * By default, the available types are:\n       * - \"unknown\" : \"--px-map-marker-group-unknown-color\" (default: gray)\n       * - \"info\" : \"--px-map-marker-group-info-color\" (default: blue)\n       * - \"warning\" : \"--px-map-marker-group-info-color\" (default: yellow)\n       * - \"important\" : \"--px-map-marker-group-info-color\" (default: red)\n       *\n       * Example #1 - FeatureCollection for `data`:\n       *\n       * ```\n       * {\n       *   \"type\" : \"FeatureCollection\",\n       *   \"features\" : [\n       *     {\n       *       \"type\": \"Feature\",\n       *       \"id\": \"001\",\n       *       \"geometry\": { ... },\n       *       \"properties\": {\n       *         \"marker-icon\": {\n       *           \"icon-base\": \"StaticIcon\",\n       *           \"icon-type\": \"info\"\n       *         }\n       *       }\n       *     },\n       *     {\n       *       \"type\": \"Feature\",\n       *       \"id\": \"002\",\n       *       \"geometry\": { ... },\n       *       \"properties\": {\n       *         \"marker-icon\": {\n       *           \"icon-base\": \"StaticIcon\",\n       *           \"icon-type\": \"warning\"\n       *         }\n       *       }\n       *     }\n       *   ]\n       * }\n       * ```\n       *\n       * Example #1 - `colorsByType` object\n       *\n       * ```\n       * {\n       *   \"info\" : \"blue\",\n       *   \"warning\" : \"red\"\n       * }\n       * ```\n       *\n       * The default `colorsByType` mapping is:\n       */\n      colorsByType: {\n        type: Object,\n        value: function(){\n          return {\n            \"unknown\" : this.getComputedStyleValue('--px-map-marker-group-unknown-color'),\n            \"info\" : this.getComputedStyleValue('--px-map-marker-group-info-color'),\n            \"warning\" : this.getComputedStyleValue('--px-map-marker-group-warning-color'),\n            \"important\" : this.getComputedStyleValue('--px-map-marker-group-important-color')\n          }\n        }\n      }\n    },\n\n    createInst(options={}) {\n      // Create a bound function that will be called to create each cluster\n      // icon for the map\n      const boundCreateClusterIcon = this._createClusterIcon.bind(this);\n      options.iconCreateFunction = boundCreateClusterIcon;\n\n      const cluster = L.markerClusterGroup(options);\n\n      if (options.data && options.data.features && options.data.features.length) {\n        this._syncDataWithMarkers(options.data.features, cluster);\n      }\n      return cluster;\n    },\n\n    updateInst(lastOptions, nextOptions) {\n      if (nextOptions.data && nextOptions.data.features && nextOptions.data.features.length) {\n        this._syncDataWithMarkers(nextOptions.data.features, this.elementInst);\n\n        // this._syncDataToMarkers(nextOptions.data.features);\n        // this.fire('px-map-marker-add');\n      }\n    },\n\n    getInstOptions() {\n      return {\n        maxClusterRadius: 150,\n        data: this.data\n      };\n    },\n\n    _createClusterIcon(cluster) {\n      const markers = cluster.getAllChildMarkers();\n      const count = markers.length;\n\n      // Count markers and group by type\n      const types = this._indexClusterMarkersByType(markers);\n      // Get the colors for each type\n      const colors = this.colorsByType;\n\n      // Get the container size for this count\n      const containerSize = this._getClusterIconSize(count);\n      // Get the path (chart stroke width) and border width for this chart\n      const pathSize = this._getStyleValueAsNum('--px-map-marker-group-cluster-path-size') || 10;\n      const borderSize = this._getStyleValueAsNum('--px-map-marker-group-cluster-border-size') || 0;\n\n      // Set up the options to send into ClusterIcon\n      const options = {\n        count: count,\n        countByType: types,\n        colorsByType: colors,\n        containerSize: containerSize,\n        pathSize: pathSize,\n        borderSize: borderSize\n      };\n\n      return new PxMap.ClusterIcon(options);\n    },\n\n    _getStyleValueAsNum(styleValName) {\n      // Try to get from the \"cache\"\n      this.__styleVals = (this.__styleVals || {});\n      if (this.__styleVals[styleValName]) return this.__styleVals[styleValName];\n\n      const computedVal = this.getComputedStyleValue(styleValName);\n\n      try {\n        const valWithoutSuffix = computedVal.replace('px','');\n        const valAsNum = Math.floor(valWithoutSuffix);\n        this.__styleVals[styleValName] = valAsNum;\n        return valAsNum;\n      } catch (e) {\n        return undefined;\n      };\n    },\n\n    _getClusterIconSize(count) {\n      // for count 1-9, size is small\n      if (count < 10) {\n        return 60;\n      }\n      // for count 10-39, size is medium\n      if ((count >= 10) && (count < 40)) {\n        return 75;\n      }\n      // for count 40+, size is large\n      if (count > 40) {\n        return 90;\n      }\n    },\n\n    /**\n     * Takes a group of marker instances and returns an object with keys of the\n     * marker types in the group and values with the number of markers in\n     * each group.\n     *\n     * @param {Array} markers - Array of marker instances\n     * @return {Object}\n     */\n    _indexClusterMarkersByType(markers) {\n      return markers.reduce((types, marker) => {\n        if (marker.featureProperties && marker.featureProperties['marker-icon'] && marker.featureProperties['marker-icon']['icon-type']) {\n          types[marker.featureProperties['marker-icon']['icon-type']] = (types[marker.featureProperties['marker-icon']['icon-type']] || 0) + 1;\n        }\n        return types;\n      }, {});\n    },\n\n    _generateClusterMarkerClasses(markerCount, markerTypeCount) {\n\n    },\n\n    // _syncDataToMarkers(featCollection, clusterInst) {\n    //   if (!featCollection || !featCollection.features || !featCollection.features.length) return;\n    //\n    //   const markers = this._markers = (this._markers || new Map());\n    //   const visited = new WeakSet();\n    //   const feats = featCollection.features;\n    //   // Keep track of any changes that will require a sync\n    //   let mustUpdateCluster = false;\n    //   // Placeholders for our loop\n    //   let i, len, marker, markerWasChanged, known, valid;\n    //\n    //   // Loop over features to add unknown features to the cluster or update known features if necessary\n    //   for (i=0, len=feats.length; i<len; i++) {\n    //     // Determine if this feature is already represented in the cluster\n    //     known = markers.has(feats[i]);\n    //     // If these tests aren't met, the feature is invalid and can't be drawn as a marker\n    //     // Any invalid markers won't be visited and will be removed\n    //     valid = ((feats[i].geometry && feats[i].geometry.type === 'Point') && (feats[i].geometry.coordinates instanceof Array && feats[i].geometry.coordinates.length === 2) && (feats[i].id));\n    //     if (!valid) continue;\n    //\n    //     // This is a valid feature we don't know. Create a marker for this feature and add it.\n    //     if (!known) {\n    //       marker = this._createMarker(feats[i]);\n    //       clusterInst.RegisterMarker(marker);\n    //       // Save this marker to the map for later syncs, and add it to visited set for our diff comparison\n    //       markers.set(feats[i].id, marker);\n    //       visited.add(feats[i].id);\n    //       mustUpdateCluster = true;\n    //     }\n    //\n    //     // We know this feature and have a marker for it. Ensure the marker is up-to-date.\n    //     if (known) {\n    //       marker = markers.get(feats[i].id);\n    //       markerWasChanged = this._updateMarkerIfNeeded(feats[i], marker);\n    //       visited.add(feats[i].id);\n    //       if (markerWasChanged) mustUpdateCluster = true;\n    //     }\n    //   }\n    //\n    //   // Delete any markers we didn't visit in our features loop\n    //   const markersToRemove = this._findForgottenMarkers(markers, visited);\n    //   if (markersToRemove) {\n    //     clusterInst.RemoveMarkers(markersToRemove);\n    //     mustUpdateCluster = true;\n    //   }\n    //\n    //   // Force an update\n    // },\n\n    _syncDataWithMarkers(newFeatures, clusterInst) {\n      if (!newFeatures.length) return;\n\n      const featuresSet = this._features = (this._features || new Set());\n      const markersMap = this._markers = (this._markers || new WeakMap());\n\n      const {featuresToAdd, featuresToUpdate, featuresToRemove, nextFeaturesSet, nextMarkersMap} = this._diffNewFeatures(newFeatures, featuresSet, markersMap);\n\n      let feature, cachedMarker, markersToOperate;\n\n      if (featuresToAdd.size) {\n        markersToOperate = [];\n        for (feature of featuresToAdd) {\n          cachedMarker = nextMarkersMap.get(feature);\n          cachedMarker.marker = this._createMarker(feature);\n          markersToOperate.push(cachedMarker.marker);\n          nextMarkersMap.set(feature, cachedMarker);\n        }\n        clusterInst.addLayers(markersToOperate);\n        markersToOperate = null;\n      }\n\n      if (featuresToUpdate.size) {\n        markersToOperate = [];\n        for (feature of featuresToUpdate) {\n          cachedMarker = nextMarkersMap.get(feature);\n          cachedMarker.marker = this._updateMarker(cachedMarker.marker);\n          markersToOperate.push(cachedMarker.marker);\n          nextMarkersMap.set(feature, cachedMarker);\n        }\n        clusterInst.refreshClusters(markersToOperate);\n        markersToOperate = null;\n      }\n\n      if (featuresToRemove.size) {\n        markersToOperate = [];\n        for (feature of featuresToRemove) {\n          cachedMarker = nextMarkersMap.get(feature);\n          this._removeMarker(cachedMarker.marker);\n          markersToOperate.push(cachedMarker.marker);\n          nextMarkersMap.delete(feature);\n        }\n        clusterInst.removeLayers(markersToOperate);\n        markersToOperate = null;\n      }\n\n      this._features = nextFeaturesSet;\n      this._markers = nextMarkersMap;\n      featuresSet.clear()\n\n      featuresToAdd.clear();\n      featuresToUpdate.clear();\n      featuresToRemove.clear();\n    },\n\n    _diffNewFeatures(newFeatures, lastFeatureSet, markerMap) {\n      // Keep track of our new feature set, which will replace `featureSet`\n      const nextFeaturesSet = new Set();\n\n      // Keep track of markers to add\n      const featuresToAdd = new Set();\n      const featuresToUpdate = new Set();\n\n      // Placeholders for our loop\n      let i, len, valid, known, cachedMarker, featureHash;\n\n      // Loop over features to add unknown features to the cluster or update known features if necessary\n      for (i=0, len=newFeatures.length; i<len; i++) {\n        // If these tests aren't met, the feature is invalid and can't be drawn as a marker\n        // Any invalid markers won't be visited and will be removed\n        valid = ((newFeatures[i].id) && (newFeatures[i].geometry && newFeatures[i].geometry.type === 'Point') && (newFeatures[i].geometry.coordinates instanceof Array && newFeatures[i].geometry.coordinates.length === 2));\n        if (!valid) continue;\n\n        // Determine if this feature is already represented in the cluster\n        known = lastFeatureSet.has(newFeatures[i]);\n\n        // This is a valid feature we don't know, create a marker for this feature and add it.\n        if (!known) {\n          // Mark this as a marker to add\n          featuresToAdd.add(newFeatures[i]);\n          // Remove from last feature set and add to next feature set\n          lastFeatureSet.delete(newFeatures[i]);\n          nextFeaturesSet.add(newFeatures[i]);\n          // Build a new cached marker object with a hash of the feature\n          cachedMarker = { marker: null, hash: JSON.stringify(newFeatures[i]) };\n          markerMap.set(newFeatures[i], cachedMarker);\n          // Skip to next loop iteration\n          continue;\n        }\n\n        // We know this feature and have a marker for it. Ensure the marker is up-to-date.\n        if (known) {\n          cachedMarker = markerMap.get(newFeatures[i]);\n          featureHash = JSON.stringify(newFeatures[i]);\n          // If there's a difference, mark this marker as one to update\n          if (cachedMarker.hash !== featureHash) {\n            featuresToUpdate.add(newFeatures[i]);\n            // Update the cached marker object with the new hash of the feature\n            cachedMarker.hash = featureHash;\n            markerMap.set(newFeatures[i], cachedMarker);\n          }\n          // Remove from last feature set and add to next feature set\n          lastFeatureSet.delete(newFeatures[i]);\n          nextFeaturesSet.add(newFeatures[i]);\n        }\n      }\n\n      // Any markers remaining in the last feature set need to be remove\n      const featuresToRemove = lastFeatureSet.size ? lastFeatureSet : new Set();\n\n      // Clear all references in the last feature set to ensure values can\n      // be garbage collected\n      lastFeatureSet.clear();\n      lastFeatureSet = null;\n\n      return {\n        featuresToAdd: featuresToAdd,\n        featuresToUpdate: featuresToUpdate,\n        featuresToRemove: featuresToRemove,\n        nextFeaturesSet: nextFeaturesSet,\n        nextMarkersMap: markerMap\n      };\n    },\n\n    // _diffLastFeaturesWithNext(lastFeatures, nextFeatures) {\n    //   // If there were no last features, all the nextFeatures are new markers\n    //   // and there are none to remove\n    //   if (!lastFeatures) {\n    //     return {\n    //       markersToAdd: nextFeatures,\n    //       markersToRemove: {size:false}\n    //     }\n    //   }\n    //\n    //   // If the last and next markers are the same, no changes to make\n    //   if (Immutable.is(lastFeatures, nextFeatures)) {\n    //     return {\n    //       markersToAdd: {size:false},\n    //       markersToRemove: {size:false}\n    //     };\n    //   }\n    //\n    //   // Otherwise, diff the Immutable lists to produce a list of those to add\n    //   // and those to remove\n    //   const addedFeatures = Immutable.Seq(nextFeatures)\n    //     .filter(feat => !lastFeatures.has(feat))\n    //     .filter(feat => feat.hasIn(['geometry', 'type'], 'Point') && feat.getIn(['geometry', 'coordinates']).size == 2 && feat.has('id'))\n    //   const removedFeatures = Immutable.Seq(lastFeatures)\n    //     .filter(feat => !nextFeatures.has(feat))\n    //\n    //   return {\n    //     markersToAdd: addedFeatures,\n    //     markersToRemove: removedFeatures\n    //   };\n    // },\n\n    _removeMarker(markerData, clusterInst){\n      debugger;\n    },\n    _createMarker(feature, clusterInst) {\n      // ... WITH MARKERCLUSTER ...\n\n      // Extract geometry (GeoJSON coordinate pairs are Lat/Lng, we need Lng/Lat,\n      // so we have to reverse)\n      const [lat, lng] = feature.geometry.coordinates;\n      // Create a marker\n      const marker = L.marker([lng, lat]);\n\n      // If any icon settings were passed with the feature, fetch them to pass\n      // to the icon constructor\n      const type = (feature.properties['marker-icon'] && feature.properties['marker-icon']['icon-type']) ? feature.properties['marker-icon']['icon-type'] : undefined;\n      const withBadge = (feature.properties['marker-icon'] && feature.properties['marker-icon']['icon-with-badge']) ? feature.properties['marker-icon']['icon-with-badge'] : undefined;\n      // Assign an icon\n      const icon = new PxMap.StaticIcon({type, withBadge});\n      marker.setIcon(icon);\n\n      // Attach the properties to the marker instance to read later\n      marker.featureProperties = feature.properties;\n\n      return marker;\n    },\n\n    /**\n     * Create and return a new `PruneCluster.Marker` configured with the geometry\n     * and properties of `feature`.\n     *\n     * @param {Object} feature - A GeoJSON feature with keys `geometry` and `properties`\n     * @return {PruneCluster.Marker}\n     */\n     _createMarkerOLDOLD(feature) {\n       debugger;\n       let marker = new PruneCluster.Marker(feature.geometry.coordinates[1], feature.geometry.coordinates[0]);\n\n       // Bind marker icon creation to `this`\n      //  marker.data.icon = this._createMarkerIcon.bind(this);\n\n       // Sets the category ID, from a lookup table\n      //  if (feature.properties['marker-icon'] && feature.properties['marker-icon']['icon-status'] && this.categoryByName[feature.properties['marker-icon']['icon-status']]) {\n      //    marker.category = this.categoryByName[feature.properties['marker-icon']['icon-status']];\n      //  }\n\n       return marker;\n     },\n\n    _createMarkerIcon(markerData, markerCategory) {\n      const options = {\n        type: 'info',\n        badge: false\n      };\n      return new PxMap.StaticIcon(options);\n    },\n\n    /**\n     * Loops over all known markers and compares each with a set of markers we\n     * recently visited. That set contains all markers active in the feature\n     * collection pased in from outside this component. Any markers not in that\n     * set will be deleted from the markers map and returned for removal.\n     *\n     * @param {Map} markers - A Map of markers. Keys are feature object IDs. Values are cluster markers.\n     * @param {WeakSet} remembered - A WeakSet (non-iterable weak reference list) of feature objects IDs whose related markers should keep around. Remove all other markers.\n     * @return {Array}\n     */\n    _findForgottenMarkers(markers, remembered) {\n      const markerList = markers.entries(); // returns array of arrays with entries [key, value] aka [featureDataObject, clusterMarkerInstance]\n      const markersToRemove = [];\n      let i, len;\n\n      for (i=0, len=markerList.length; i<len; i++) {\n        // We saw this marker in the features, so it can stick around\n        if (remembered.has(markerList[i][0])) continue;\n        // Otherwise, remove it from the markers map and prep it for deletion\n        markersToRemove.push(markerList[i][1]);\n        markers.delete(markerList[i][0]);\n      }\n\n      return markersToRemove;\n    },\n\n    /**\n     * Ensure the data in the `feature` matches the configured `marker`. If\n     * it does not match, update the marker.\n     *\n     * @param {Object} feature - A GeoJSON feature with keys `geometry` and `properties`\n     * @param {PruneCluster.Marker} marker - A PruneCluster marker instance that is in the cluster\n     */\n    _ensureMarkerMatchesData(feature, marker) {\n      // ...\n    }\n\n\n    // listeners: {\n    //   'px-map-layer-instance-created' : 'shouldUpdateInst'\n    // },\n    //\n    // categoryById: {\n    //   0 : 'unknown',\n    //   1 : 'info',\n    //   2 : 'warning',\n    //   3 : 'important'\n    // },\n    //\n    // categoryByName: {\n    //   'unknown'   : 0,\n    //   'info'      : 1,\n    //   'warning'   : 2,\n    //   'important' : 3\n    // },\n    //\n    // createInst() {\n    //   this._markers = this._markers || new Map();\n    //   return new PruneClusterForLeaflet();\n    // },\n    //\n    // updateInst(lastOptions, nextOptions) {\n    //   if (nextOptions.data && nextOptions.data.features && nextOptions.data.features.length) {\n    //     this._updateMarkers(nextOptions.data.features);\n    //     this.fire('px-map-marker-add');\n    //   }\n    // },\n    //\n    // getOptions() {\n    //   return {\n    //     data: this.data || {}\n    //   };\n    // },\n    //\n    // _updateMarkers(features) {\n    //   if (!features || !(features instanceof Array) || !features.length) return;\n    //\n    //   for (let feature of features) {\n    //     if (this._markers.has(feature)) continue;\n    //\n    //     // feature.geometry.coordinates is [lng,lat] and marker wants lat,lng\n    //     let marker = this._createMarker(feature);\n    //     this.elementInst.RegisterMarker(marker);\n    //     this._markers.set(feature, marker);\n    //   }\n    // },\n    //\n    //\n    //\n    // getIcon(data, category) {\n    //   return this.createStaticIcon(this.getIconOptions(category));\n    // },\n    //\n    // getIconOptions(category) {\n    //   return this.getStaticIconOptions({ type: this.categoryById[category] });\n    // }\n  };\n  /* Bind MarkerGroup behavior */\n  namespace.MarkerGroup = [\n    namespace.Layer,\n    MarkerGroupImpl\n  ];\n\n})();\n"]}