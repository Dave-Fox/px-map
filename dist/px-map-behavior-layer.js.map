{"version":3,"sources":["px-map-behavior-layer.es6.js"],"names":["namespace","window","PxMapBehavior","LayerImpl","attached","__elAttached","notifyInstReady","canAddInst","detached","shouldRemoveInst","addInst","parent","addLayer","elementInst","removeInst","remove","isReady","fire","Layer","Element","ParentLayerImpl","listeners","created","_attachedChildren","WeakMap","_detachLayerChildren","_tryToAddAllChildren","evt","srcElement","_attachLayerChildren","_tryToAddOneChild","stopPropagation","_attachLayerChild","children","getEffectiveChildren","length","child","childEl","has","shouldAddInst","set","async","_detachLayerChild","delete","ParentLayer"],"mappings":"aAAA,CAAC,UAAW,CACV,aAOA,GAAMA,WAAaC,OAAOC,aAAP,CAAuBD,OAAOC,aAAP,EAAwB,EAAlE,CAOA,GAAMC,WAAY,CAIhBC,QAJgB,oBAIL,CACT,KAAKC,YAAL,CAAoB,IAApB,CACA,KAAKC,eAAL,CAAqB,KAAKC,UAAL,EAArB,CACD,CAPe,CAYhBC,QAZgB,oBAYL,CACT,KAAKH,YAAL,CAAoB,KAApB,CACA,KAAKI,gBAAL,EACD,CAfe,CAmBhBC,OAnBgB,kBAmBRC,MAnBQ,CAmBA,CACdA,OAAOC,QAAP,CAAgB,KAAKC,WAArB,CACD,CArBe,CAuBhBC,UAvBgB,qBAuBLH,MAvBK,CAuBG,CACjB,KAAKE,WAAL,CAAiBE,MAAjB,EACD,CAzBe,CA2ChBR,UA3CgB,sBA2CH,CACX,MAAO,KACR,CA7Ce,CAsDhBD,eAtDgB,2BAsDc,IAAdU,QAAc,2DAAN,IAAM,CAC5B,GAAI,CAACA,OAAL,CAAc,MAAO,MAAP,CACd,KAAKC,IAAL,CAAU,2BAAV,EACA,MAAO,KACR,CA1De,CAAlB,CA6DAjB,UAAUkB,KAAV,CAAkB,CAChBlB,UAAUmB,OADM,CAEhBhB,SAFgB,CAAlB,CAUA,GAAMiB,iBAAkB,CACtBC,UAAW,CACT,gCAAkC,sBADzB,CAET,4BAA8B,mBAFrB,CADW,CAMtBC,OANsB,mBAMZ,CAER,KAAKC,iBAAL,CAAyB,KAAKA,iBAAL,EAA0B,GAAIC,QACxD,CATqB,CAWtBhB,QAXsB,oBAWX,CACT,KAAKiB,oBAAL,EACD,CAbqB,CAiBtBC,oBAjBsB,+BAiBDC,GAjBC,CAiBI,CAGxB,GAAI,CAAC,KAAKd,WAAN,EAAqBc,IAAIC,UAAJ,GAAmB,IAA5C,CAAkD,OAGlD,KAAKC,oBAAL,EACD,CAxBqB,CA0BtBC,iBA1BsB,4BA0BJH,GA1BI,CA0BC,CAErB,GAAIA,IAAIC,UAAJ,GAAmB,IAAvB,CAA6B,OAG7BD,IAAII,eAAJ,GAGA,GAAI,CAAC,KAAKlB,WAAV,CAAuB,OAEvB,KAAKmB,iBAAL,CAAuBL,IAAIC,UAA3B,CACD,CArCqB,CAuCtBC,oBAvCsB,gCAuCC,CACrB,GAAMI,UAAW,KAAKC,oBAAL,EAAjB,CACA,GAAI,CAACD,QAAD,EAAa,CAACA,SAASE,MAA3B,CAAmC,OAFd,gGAIrB,kBAAkBF,QAAlB,oHAA4B,IAAnBG,MAAmB,aAC1B,KAAKJ,iBAAL,CAAuBI,KAAvB,CACD,CANoB,4LAOtB,CA9CqB,CAgDtBJ,iBAhDsB,4BAgDJK,OAhDI,CAgDK,gBACzB,GAAI,KAAKd,iBAAL,CAAuBe,GAAvB,CAA2BD,OAA3B,GAAuC,CAACA,QAAQE,aAAhD,EAAiE,CAACF,QAAQ9B,UAA1E,EAAwF,CAAC8B,QAAQ9B,UAAR,EAA7F,CAAmH,OACnH,KAAKgB,iBAAL,CAAuBiB,GAAvB,CAA2BH,OAA3B,CAAoC,IAApC,EAEA,KAAKI,KAAL,CAAW,UAAM,CAAEJ,QAAQE,aAAR,CAAsB,MAAK1B,WAA3B,CAA0C,CAA7D,CACD,CArDqB,CAyDtBY,oBAzDsB,gCAyDC,CACrB,GAAMQ,UAAW,KAAKC,oBAAL,EAAjB,CACA,GAAI,CAACD,QAAD,EAAa,CAACA,SAASE,MAA3B,CAAmC,OAFd,mGAIrB,mBAAkBF,QAAlB,yHAA4B,IAAnBG,MAAmB,cAC1B,KAAKM,iBAAL,CAAuBN,KAAvB,CACD,CANoB,mMAOtB,CAhEqB,CAkEtBM,iBAlEsB,4BAkEJL,OAlEI,CAkEK,iBACzB,GAAI,CAAC,KAAKd,iBAAL,CAAuBe,GAAvB,CAA2BD,OAA3B,CAAD,EAAwC,CAACA,QAAQ5B,gBAArD,CAAuE,OACvE,KAAKc,iBAAL,CAAuBoB,MAAvB,CAA8BN,OAA9B,EAEA,KAAKI,KAAL,CAAW,UAAM,CAAEJ,QAAQ5B,gBAAR,CAAyB,OAAKI,WAA9B,CAA6C,CAAhE,CACD,CAvEqB,CAAxB,CA0EAb,UAAU4C,WAAV,CAAwB,CAACxB,eAAD,CAEzB,CAlKD","file":"px-map-behavior-layer.js","sourcesContent":["(function() {\n  'use strict';\n\n  /****************************************************************************\n   * BEHAVIORS\n   ****************************************************************************/\n\n  /* Ensures the behavior namespace is created */\n  const namespace = (window.PxMapBehavior = window.PxMapBehavior || {});\n\n  /**\n   *\n   *\n   * @polymerBehavior PxMapBehavior.Layer\n   */\n  const LayerImpl = {\n    // When this element is attached to the DOM, fire an event to notify\n    // a parent that it is ready\n\n    attached() {\n      this.__elAttached = true;\n      this.notifyInstReady(this.canAddInst());\n    },\n\n    // When this element is detached from the DOM, its elementInst should be\n    // removed from the parent\n\n    detached() {\n      this.__elAttached = false;\n      this.shouldRemoveInst();\n    },\n\n    // Methods to bind to/unbind from parent\n\n    addInst(parent) {\n      parent.addLayer(this.elementInst);\n    },\n\n    removeInst(parent) {\n      this.elementInst.remove();\n    },\n\n    /**\n     * Some element instances may require a minimum number of defined options\n     * to be able to attach to their parent. If those options are defined via.\n     * attributes, they may not be deserialized or even set before the `willAddInst`\n     * method is called.\n     *\n     * Elements that need to defer until some options are set should override\n     * the `canAddInst` method and return `false` if the method\n     *\n     * Elements that may need to defer until some options are ready should\n     * override `instReady` and set it to `false` by default.\n     *\n     * Later, when the `updateInst` function is called, the element should check\n     * if all required options are set and call the method `this.notifyInstReady(true)`\n     * to trigger an event the parent will catch and use to attach this element.\n     */\n    canAddInst() {\n      return true;\n    },\n\n    /**\n     * If this element's instance is ready to create and add to its parent,\n     * fires an event the parent will catch.\n     *\n     * @param {Boolean} isReady - If `true` instance parent will be notified\n     * @return {Boolean} - If `true` the parent was notified\n     */\n    notifyInstReady(isReady=true) {\n      if (!isReady) return false;\n      this.fire('px-map-layer-ready-to-add');\n      return true;\n    }\n  };\n  /* Bind Layer behavior */\n  namespace.Layer = [\n    namespace.Element,\n    LayerImpl\n  ];\n\n  /**\n   *\n   *\n   * @polymerBehavior PxMapBehavior.ParentLayer\n   */\n  const ParentLayerImpl = {\n    listeners: {\n      'px-map-layer-instance-created' : '_tryToAddAllChildren',\n      'px-map-layer-ready-to-add' : '_tryToAddOneChild'\n    },\n\n    created() {\n      // Use a WeakMap to keep track of our attached children\n      this._attachedChildren = this._attachedChildren || new WeakMap();\n    },\n\n    detached() {\n      this._detachLayerChildren();\n    },\n\n    // Handles attaching children throughout this element's lifecycle\n\n    _tryToAddAllChildren(evt) {\n      // If this element's elementInst isn't ready, halt and wait until later\n      // If this event isn't coming from this element, do not handle\n      if (!this.elementInst || evt.srcElement !== this) return;\n\n      // If my own elementInst was just created, loop over children and try to attach them\n      this._attachLayerChildren();\n    },\n\n    _tryToAddOneChild(evt) {\n      // If the added-to-dom event belongs to this element, just return and let it bubble\n      if (evt.srcElement === this) return;\n\n      // This element is the parent, so stop this event from bubbling\n      evt.stopPropagation();\n\n      // If I have no elementInst, halt and wait until later\n      if (!this.elementInst) return;\n\n      this._attachLayerChild(evt.srcElement);\n    },\n\n    _attachLayerChildren() {\n      const children = this.getEffectiveChildren();\n      if (!children || !children.length) return;\n\n      for (let child of children) {\n        this._attachLayerChild(child);\n      }\n    },\n\n    _attachLayerChild(childEl) {\n      if (this._attachedChildren.has(childEl) || !childEl.shouldAddInst || !childEl.canAddInst || !childEl.canAddInst()) return;\n      this._attachedChildren.set(childEl, true);\n\n      this.async(() => { childEl.shouldAddInst(this.elementInst); });\n    },\n\n    // Handles detaching children throughout this element's lifecycle\n\n    _detachLayerChildren() {\n      const children = this.getEffectiveChildren();\n      if (!children || !children.length) return;\n\n      for (let child of children) {\n        this._detachLayerChild(child);\n      }\n    },\n\n    _detachLayerChild(childEl) {\n      if (!this._attachedChildren.has(childEl) || !childEl.shouldRemoveInst) return;\n      this._attachedChildren.delete(childEl);\n\n      this.async(() => { childEl.shouldRemoveInst(this.elementInst); });\n    }\n  };\n  /* Bind ParentLayer behavior */\n  namespace.ParentLayer = [ParentLayerImpl];\n\n})();\n"]}