{"version":3,"sources":["px-map-behavior-distribute-properties.es6.js"],"names":["DistributeProperties","attached","distributions","length","_addDistributionObservers","detached","_removeDistributionObservers","properties","property","findPropAsProp","foundStrings","exec","propertyName","childPropertyName","_distributeOnNewChildren","_distributeOnPropertyChange","newChildDistributors","__newChildDistributors","distributeFns","values","fn","Polymer","dom","unobserveNodes","distributors","Map","has","distributeFn","_distributePropertyToChildren","distributorInstance","observeNodes","set","__propertyChangeDistributors","Bind","addPropertyEffect","applyPropertyFn","children","getEffectiveChildren","child","debounce","is","namespace","window","PxMapBehavior"],"mappings":"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","file":"px-map-behavior-distribute-properties.js","sourcesContent":["(function() {\n  'use strict';\n\n  /**\n   * When light DOM children are distributed into a `px-map` framework component,\n   * that component will often have to share a reference to one of its properties\n   * with the child. This behavior wraps around that use case, ensuring that\n   * properties will be applied to any distributed light DOM children and that\n   * changes to those properties on the parent will trigger a re-distribution\n   * to the children that keeps them up-to-date.\n   *\n   * Distributions should be configured in the component's Polymer constructor\n   * in a similar way to the `observers` block provided by the Polymer library.\n   *\n   * For example, this `simple-parent-component` distributes its `name` property\n   * it any light DOM children:\n   *\n   * ```\n   * <dom-module id=\"simple-parent-component\">\n   *   <template>\n   *     <!-- ... -->\n   *   </template>\n   * </dom-module>\n   * <script>\n   *   Polymer({\n   *     is: 'simple-parent-component',\n   *     properties: {\n   *       name: {\n   *         type: String\n   *       }\n   *     },\n   *     distributions: ['name']\n   *   });\n   * </script>\n   * ```\n   *\n   * When this parent component is placed on a page, anything placed in its\n   * light DOM will automatically be set up with a `name` property that\n   * will always inherit its value (and any updates to that value) from\n   * the parent `name` property.\n   *\n   * For example, the light DOM children `simple-child-component` will have\n   * the `name` property distributed to them with the value `Some Name`:\n   *\n   * ```\n   * <simple-parent-component name=\"Some Name\">\n   *   <simple-child-component></simple-child-component>\n   * </simple-parent-component>\n   * <script>\n   *   // The child has inherited the parent's name\n   *   var child = document.querySelector('simple-child-component');\n   *   console.log(child.name); // => 'Some Name'\n   *\n   *   // Updating the name of the parent will also update the child's name\n   *   var parent = document.querySelector('simple-parent-component');\n   *   parent.setAttribute('name', 'New Name');\n   *   console.log(child.name); // => 'New Name'\n   * </script>\n   * ```\n   *\n   * @polymerBehavior PxMapBehavior.DistributeProperties\n   */\n  const DistributeProperties = {\n    attached() {\n      if (this.distributions && this.distributions.length) {\n        this._addDistributionObservers(this.distributions);\n      }\n    },\n\n    detached() {\n      if (this.distributions && this.distributions.length) {\n        this._removeDistributionObservers();\n      }\n    },\n\n    /**\n     * Creates new observers that watch for new light DOM children to be\n     * distributed and watch for changes to a `property` and apply that\n     * `property` to the children.\n     *\n     * @param {Array} properties - A list of property names to attach to children\n     */\n    _addDistributionObservers(properties) {\n      for (let property of properties) {\n        // If the string is formatted like 'property as newProperty', distribute\n        // the parent.property on the children as child.newProperty\n        const findPropAsProp = /^([\\w]+)\\b as \\b([\\w]+)$/g;\n        const foundStrings = findPropAsProp.exec(property);\n        const propertyName = (foundStrings||[]).length ? foundStrings[1] : property;\n        const childPropertyName = (foundStrings||[]).length ? foundStrings[2] : property;\n\n        this._distributeOnNewChildren(propertyName, childPropertyName);\n        this._distributeOnPropertyChange(propertyName, childPropertyName);\n      }\n    },\n\n    /**\n     * Removes all distribution observers when the host is detached.\n     */\n    _removeDistributionObservers() {\n      // Remove parent -> child light DOM distribution observers\n      const newChildDistributors = this.__newChildDistributors;\n      if (newChildDistributors && newChildDistributors.length) {\n        const distributeFns = newChildDistributors.values();\n        for (let fn of distributeFns) {\n          Polymer.dom(this).unobserveNodes(fn);\n        }\n      }\n\n      // For now, it seems like Polymer.Bind automatically cleans up all the\n      // dynamic property change effects, so we'll end here.\n      // If performance becomes an issue, we may need to look into manually\n      // removing the effects created `Polymer.Bind.addPropertyEffect`.\n    },\n\n    /**\n     * Attaches an observer that is triggered when light DOM child nodes are\n     * distributed or updated. The `propertyName` property and value from the\n     * parent will be applied to the children automatically.\n     *\n     * @param {String} propertyName - The name of the property to distribute to light DOM children\n     * @param {String} childPropertyName - The name the property will be given on the children (can be the same as `propertyName`)\n     */\n    _distributeOnNewChildren(propertyName, childPropertyName) {\n      const distributors = this.__newChildDistributors || new Map();\n      if (!distributors.has(propertyName)) {\n        // @TODO: This would be the way to observe without Polymer.dom, but due\n        // to the way Polymer ~1.6 orchestrates DOM manipulation, it doesn't work.\n        // Revert to this code in a newer version:\n        // const boundObserverFn = this[observeFnName].bind(this);\n        // this[observerWrapper] = new MutationObserver(boundObserverFn);\n        // this[observerWrapper].observe(this, {childList:true});\n        let distributeFn = () => this._distributePropertyToChildren(propertyName, childPropertyName);\n        let distributorInstance = Polymer.dom(this).observeNodes(distributeFn);\n        distributors.set(propertyName, distributorInstance);\n      }\n    },\n\n    /**\n     * Attaches a `Polymer.Bind` complex property observer that watches for changes\n     * to the value of `propertyName` and syncs the new value to children.\n     *\n     * @param {String} propertyName - The name of the property to watch for changes\n     * @param {String} childPropertyName - The name the property will be given on the children (can be the same as `propertyName`)\n     */\n    _distributeOnPropertyChange(propertyName, childPropertyName) {\n      const distributors = this.__propertyChangeDistributors || new Map();\n      if (!distributors.has(propertyName)) {\n        // @TODO: This is Polymer 1.X-flavored code that relies on the internal\n        // `Polymer.Bind.addPropertyEffect` API. In the future, we should use\n        // the hooks Polymer 2.0 will provide into the observer API vs. calling\n        // this internal watcher.\n        let distributeFn = () => this._distributePropertyToChildren(propertyName, childPropertyName);\n        Polymer.Bind.addPropertyEffect(this, propertyName, 'function', distributeFn);\n        Polymer.Bind.addPropertyEffect(this, `${propertyName}.*`, 'function', distributeFn);\n        distributors.set(propertyName, true);\n      }\n    },\n\n    /**\n     * Distribute the parent property `propertyName` to all child elements as\n     * `childPropertyName` with value `propertyValue`. Loops through distributed\n     * light DOM children (found with `getEffectiveChildren`) and update the\n     * child's property `childPropertyName` if it is out-of-sync with the parent's.\n     *\n     * @param {String} propertyName - The name of the property to distribute to light DOM children\n     * @param {String} childPropertyName - The name the property will be given on the children (can be the same as `propertyName`)\n     */\n    _distributePropertyToChildren(propertyName, childPropertyName) {\n      if (!propertyName || !childPropertyName || !this[propertyName] || typeof this[propertyName] === 'undefined') return;\n\n      const applyPropertyFn = () => {\n        const children = this.getEffectiveChildren();\n        for (let child of children) {\n          if (!child[childPropertyName] || child[childPropertyName] !== this[propertyName]) {\n            child[childPropertyName] = this[propertyName];\n          }\n        }\n      }\n\n      this.debounce(`apply-property-${propertyName}-reference-to-${this.is}-children`, applyPropertyFn, 1);\n    },\n  };\n\n  const namespace = (window.PxMapBehavior = window.PxMapBehavior || {});\n  namespace.DistributeProperties = DistributeProperties;\n})()\n"]}